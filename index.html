<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Othello Analyst V2.5 (IID + ClosedParity)</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <script src="https://unpkg.com/@phosphor-icons/web"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

        body {
            font-family: 'Inter', system-ui, sans-serif;
            background-color: #f5f5f4;
            touch-action: manipulation;
        }

        /* --- Textures & Board --- */
        .wood-texture {
            background-color: #e5ccab;
            background-image:
                linear-gradient(90deg, rgba(255, 255, 255, 0.1) 0%, rgba(0, 0, 0, 0.05) 100%),
                url("data:image/svg+xml,%3Csvg width='100' height='100' viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.6' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100' height='100' filter='url(%23noise)' opacity='0.08'/%3E%3C/svg%3E");
            box-shadow: inset 2px 2px 5px rgba(255, 255, 255, 0.3), inset -2px -2px 5px rgba(0, 0, 0, 0.1);
        }

        .cell {
            background-color: #5c8d73;
            box-shadow: inset 1px 1px 3px rgba(0, 0, 0, 0.2);
            transition: background-color 0.2s;
            position: relative;
        }

        .board-grid {
            background-color: #2f4f3e;
            padding: 2px;
            border-radius: 2px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3);
        }

        /* --- Discs --- */
        .disc {
            width: 85%;
            height: 85%;
            border-radius: 50%;
            transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 12px;
            font-weight: 700;
            user-select: none;
            z-index: 10;
            pointer-events: none;
        }

        .disc.black {
            background: radial-gradient(circle at 35% 35%, #555, #1a1a1a, #000);
            box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.6), inset 1px 1px 2px rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.9);
        }

        .disc.white {
            background: radial-gradient(circle at 35% 35%, #fff, #f0f0f0, #d1d1d1);
            box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.4), inset -1px -1px 2px rgba(0, 0, 0, 0.1);
            color: #333;
        }

        .last-move-marker {
            position: absolute;
            width: 8px;
            height: 8px;
            background-color: #ef4444;
            border-radius: 50%;
            box-shadow: 0 0 4px rgba(239, 68, 68, 0.8);
            z-index: 20;
            pointer-events: none;
        }

        .legal-move-hint {
            width: 25%;
            height: 25%;
            border-radius: 50%;
            background-color: rgba(0, 0, 0, 0.2);
            box-shadow: inset 0 0 2px rgba(0, 0, 0, 0.2);
            z-index: 5;
            pointer-events: none;
        }

        .cell:hover .legal-move-hint {
            background-color: rgba(0, 0, 0, 0.4);
            transform: scale(1.2);
            transition: all 0.2s;
        }

        /* --- Analysis Scores --- */
        .eval-score {
            position: absolute;
            z-index: 30;
            font-weight: 800;
            font-size: 1.1rem;
            text-shadow: -1px -1px 0 rgba(0, 0, 0, 0.6), 1px -1px 0 rgba(0, 0, 0, 0.6), -1px 1px 0 rgba(0, 0, 0, 0.6), 1px 1px 0 rgba(0, 0, 0, 0.6);
            pointer-events: none;
            transition: all 0.2s;
            font-family: 'Inter', monospace;
        }

        .score-best {
            color: #3b82f6;
            z-index: 31;
            transform: scale(1.2);
            text-shadow: -1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff, 1px 1px 0 #fff;
        }

        .score-normal {
            color: #fbbf24;
        }

        @media (min-width: 768px) {
            .eval-score {
                font-size: 1.3rem;
            }
        }

        /* --- UI Elements --- */
        input[type=range].depth-slider {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }

        input[type=range].depth-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #78350f;
            cursor: pointer;
            margin-top: -6px;
        }

        input[type=range].depth-slider::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #e7e5e4;
            border-radius: 2px;
        }

        /* Weight Sliders */
        input[type=range].weight-slider {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }

        input[type=range].weight-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 14px;
            width: 14px;
            border-radius: 50%;
            background: #4f46e5;
            cursor: pointer;
            margin-top: -5px;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }

        input[type=range].weight-slider::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #e0e7ff;
            border-radius: 2px;
        }

        /* Toggle Switch */
        .toggle-checkbox:checked {
            right: 0;
            border-color: #4f46e5;
        }

        .toggle-checkbox:checked+.toggle-label {
            background-color: #4f46e5;
        }

        .active-move {
            background-color: #e5e7eb;
            border-left: 4px solid #4b5563;
            font-weight: 700;
        }

        .analyzing-pulse {
            animation: pulse-purple 2s infinite;
        }

        @keyframes pulse-purple {
            0% {
                box-shadow: 0 0 0 0 rgba(126, 34, 206, 0.4);
            }

            70% {
                box-shadow: 0 0 0 10px rgba(126, 34, 206, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(126, 34, 206, 0);
            }
        }

        .edit-overlay {
            opacity: 0.5;
            pointer-events: none;
            filter: grayscale(1);
        }

        .brush-active {
            ring: 2px solid #3b82f6;
            transform: scale(1.1);
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 100;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .modal-overlay.hidden {
            display: none !important;
        }

        .modal-content {
            background: white;
            padding: 24px;
            border-radius: 12px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
            max-width: 90%;
            width: 320px;
            text-align: center;
        }

        .custom-scroll::-webkit-scrollbar {
            width: 4px;
        }

        .custom-scroll::-webkit-scrollbar-track {
            background: transparent;
        }

        .custom-scroll::-webkit-scrollbar-thumb {
            background: #d6d3d1;
            border-radius: 2px;
        }

        /* Status Bar Animation */
        .status-pill {
            transition: all 0.3s ease;
        }

        .status-idle {
            background-color: #e7e5e4;
            color: #57534e;
        }

        .status-working {
            background-color: #fef3c7;
            color: #92400e;
            animation: pulse-yellow 2s infinite;
        }

        .status-done {
            background-color: #dcfce7;
            color: #166534;
        }

        @keyframes pulse-yellow {
            0% {
                opacity: 0.8;
            }

            50% {
                opacity: 1;
            }

            100% {
                opacity: 0.8;
            }
        }

        /* Dev Mode Animations */
        #dev-chevron.rotate-180 {
            transform: rotate(180deg);
        }
    </style>
    <link rel="stylesheet" href="/index.css">
</head>

<body class="min-h-screen flex flex-col items-center py-6 md:py-10 px-4 text-stone-800">

    <div class="w-full max-w-6xl flex flex-col lg:flex-row gap-8 items-start justify-center">

        <!-- Left: Board -->
        <div class="flex-1 flex flex-col items-center w-full max-w-[600px] mx-auto lg:mx-0">
            <!-- Header -->
            <div class="w-full flex justify-between items-end mb-4">
                <div>
                    <h1 class="text-3xl font-bold tracking-tight text-stone-800 flex items-center gap-2">
                        <i class="ph ph-lightning text-teal-600"></i> Othello Analyst
                        <span
                            class="px-2 py-0.5 rounded text-[12px] font-bold bg-stone-800 text-white border border-stone-600 uppercase tracking-wide">V2.5
                            IID</span>
                    </h1>
                </div>

                <div class="flex gap-4 text-sm font-medium text-stone-600">
                    <label class="flex items-center gap-2 cursor-pointer hover:text-stone-900 transition">
                        <input type="checkbox" id="show-numbers" class="accent-stone-700"
                            onchange="uiRenderCurrentState()">
                        <span>#</span>
                    </label>
                    <label class="flex items-center gap-2 cursor-pointer hover:text-stone-900 transition">
                        <input type="checkbox" id="show-legal" class="accent-stone-700" checked
                            onchange="uiRenderCurrentState()">
                        <span>Legal</span>
                    </label>
                </div>
            </div>

            <!-- Editor Toolbar -->
            <div id="editor-toolbar"
                class="hidden w-full bg-white p-3 rounded-xl shadow-sm border border-orange-200 mb-4 flex items-center justify-between animate-in fade-in slide-in-from-top-2">
                <div class="flex items-center gap-2">
                    <span class="text-xs font-bold text-orange-600 uppercase mr-2">Edit Mode</span>
                    <button onclick="setBrush(BLACK)" id="brush-black"
                        class="w-10 h-10 rounded-full bg-stone-100 flex items-center justify-center hover:bg-stone-200 transition border border-stone-300">
                        <div class="w-6 h-6 rounded-full bg-black shadow-sm"></div>
                    </button>
                    <button onclick="setBrush(WHITE)" id="brush-white"
                        class="w-10 h-10 rounded-full bg-stone-100 flex items-center justify-center hover:bg-stone-200 transition border border-stone-300">
                        <div class="w-6 h-6 rounded-full bg-white border border-stone-300 shadow-sm"></div>
                    </button>
                    <button onclick="setBrush(EMPTY)" id="brush-empty"
                        class="w-10 h-10 rounded-full bg-stone-100 flex items-center justify-center hover:bg-stone-200 transition border border-stone-300 text-stone-500"
                        title="Eraser">
                        <i class="ph ph-eraser text-xl"></i>
                    </button>
                </div>
                <button onclick="finishEditing()"
                    class="px-4 py-2 bg-stone-800 text-white text-sm font-bold rounded-lg hover:bg-stone-700 shadow-sm">
                    Done
                </button>
            </div>

            <!-- Board Area -->
            <div class="relative p-3 rounded-lg shadow-2xl wood-texture select-none touch-none">
                <!-- Coords -->
                <div
                    class="absolute top-0 left-8 right-3 h-6 flex justify-between items-end text-xs font-bold opacity-60 pointer-events-none">
                    <div class="flex-1 text-center">a</div>
                    <div class="flex-1 text-center">b</div>
                    <div class="flex-1 text-center">c</div>
                    <div class="flex-1 text-center">d</div>
                    <div class="flex-1 text-center">e</div>
                    <div class="flex-1 text-center">f</div>
                    <div class="flex-1 text-center">g</div>
                    <div class="flex-1 text-center">h</div>
                </div>
                <div
                    class="absolute top-3 bottom-3 left-0 w-6 flex flex-col justify-between items-center text-xs font-bold opacity-60 pointer-events-none pt-1.5 pb-1.5">
                    <div class="flex-1 flex items-center">1</div>
                    <div class="flex-1 flex items-center">2</div>
                    <div class="flex-1 flex items-center">3</div>
                    <div class="flex-1 flex items-center">4</div>
                    <div class="flex-1 flex items-center">5</div>
                    <div class="flex-1 flex items-center">6</div>
                    <div class="flex-1 flex items-center">7</div>
                    <div class="flex-1 flex items-center">8</div>
                </div>

                <div id="board"
                    class="board-grid grid grid-cols-8 grid-rows-8 w-[320px] h-[320px] sm:w-[400px] sm:h-[400px] md:w-[500px] md:h-[500px] gap-0.5 ml-5 mt-4"
                    onmousedown="handleBoardMouseDown(event)" onmouseup="handleBoardMouseUp(event)"
                    onmouseleave="handleBoardMouseUp(event)" ontouchstart="handleBoardTouchStart(event)"
                    ontouchend="handleBoardTouchEnd(event)">
                </div>

                <!-- Game Result Message -->
                <div id="game-result-msg"
                    class="absolute inset-0 flex items-center justify-center pointer-events-none hidden z-40">
                    <div
                        class="bg-stone-900/90 text-white px-6 py-4 rounded-xl shadow-2xl backdrop-blur-sm transform scale-110 animate-in fade-in zoom-in duration-300">
                        <div class="text-2xl font-bold text-center mb-1" id="result-title">Black Wins!</div>
                        <div class="text-sm text-stone-300 font-mono text-center" id="result-score">40 - 24</div>
                    </div>
                </div>
            </div>

            <!-- Status Bar below board -->
            <div class="mt-4 w-full flex items-center justify-center">
                <div id="status-bar-pill"
                    class="status-pill status-idle px-5 py-2 rounded-full text-xs font-bold flex items-center gap-2 shadow-sm border border-stone-200">
                    <i id="status-icon" class="ph ph-check-circle text-lg"></i>
                    <span id="status-msg">Ready</span>
                </div>
            </div>

            <!-- Player Info -->
            <div class="mt-4 flex justify-between items-center w-full px-2">
                <div class="flex items-center gap-4 transition-opacity duration-300" id="black-panel">
                    <div class="relative">
                        <div class="w-12 h-12 rounded-full bg-black shadow-lg flex items-center justify-center border-2 border-transparent"
                            id="black-indicator">
                            <span class="text-white font-bold text-lg" id="black-count">2</span>
                        </div>
                        <div id="black-turn-dot"
                            class="absolute -bottom-2 left-1/2 -translate-x-1/2 w-2 h-2 bg-stone-800 rounded-full opacity-0 transition-opacity">
                        </div>
                    </div>
                    <div class="font-bold text-stone-700 hidden sm:block">Black</div>
                </div>

                <div class="text-center">
                    <div id="status-text" class="text-lg font-bold text-stone-800">Ready</div>
                    <div id="move-text" class="text-xs text-stone-500 font-mono mt-1">-</div>
                    <div id="engine-type" class="text-[10px] uppercase font-bold text-stone-400 mt-1">Engine: Standby
                    </div>
                </div>

                <div class="flex items-center gap-4 transition-opacity duration-300 flex-row-reverse" id="white-panel">
                    <div class="relative">
                        <div class="w-12 h-12 rounded-full bg-white shadow-lg flex items-center justify-center border-2 border-stone-200"
                            id="white-indicator">
                            <span class="text-stone-800 font-bold text-lg" id="white-count">2</span>
                        </div>
                        <div id="white-turn-dot"
                            class="absolute -bottom-2 left-1/2 -translate-x-1/2 w-2 h-2 bg-stone-800 rounded-full opacity-0 transition-opacity">
                        </div>
                    </div>
                    <div class="font-bold text-stone-700 hidden sm:block">White</div>
                </div>
            </div>

            <!-- Navigation Controls -->
            <div id="nav-controls"
                class="mt-6 w-full bg-white p-4 rounded-xl shadow-sm border border-stone-200 flex flex-col gap-3 transition-opacity">
                <input type="range" id="history-slider" min="0" max="0" value="0"
                    class="w-full accent-stone-700 cursor-pointer" oninput="jumpToStep(parseInt(this.value))">
                <div class="flex justify-center gap-4">
                    <button onclick="jumpToStep(0)"
                        class="p-2 text-stone-600 hover:text-stone-900 hover:bg-stone-100 rounded-lg transition"
                        title="Start">
                        <i class="ph ph-skip-back-circle text-2xl"></i>
                    </button>
                    <button onclick="step(-1)"
                        class="p-2 text-stone-600 hover:text-stone-900 hover:bg-stone-100 rounded-lg transition"
                        title="Previous (Left Arrow)">
                        <i class="ph ph-arrow-circle-left text-2xl"></i>
                    </button>
                    <button onclick="step(1)"
                        class="p-2 text-stone-600 hover:text-stone-900 hover:bg-stone-100 rounded-lg transition"
                        title="Next (Right Arrow)">
                        <i class="ph ph-arrow-circle-right text-2xl"></i>
                    </button>
                    <button onclick="jumpToEnd()"
                        class="p-2 text-stone-600 hover:text-stone-900 hover:bg-stone-100 rounded-lg transition"
                        title="End">
                        <i class="ph ph-skip-forward-circle text-2xl"></i>
                    </button>
                </div>
            </div>

            <!-- EDIT BUTTON -->
            <button id="btn-edit-toggle" onclick="toggleEditMode()"
                class="mt-4 w-full bg-white border border-stone-300 text-stone-600 font-bold py-2 px-4 rounded-lg hover:bg-stone-50 transition text-sm flex items-center justify-center gap-2">
                <i class="ph ph-pencil-simple"></i> Edit Board
            </button>
        </div>

        <!-- Right: Input & History -->
        <div id="sidebar-panel" class="w-full lg:w-80 flex flex-col gap-4 h-full transition-opacity duration-300">
            <div class="bg-white p-5 rounded-xl shadow-sm border border-stone-200">
                <div class="flex justify-between items-center mb-2">
                    <h2 class="text-sm font-bold text-stone-800 uppercase tracking-wide">Input Moves</h2>
                    <div class="flex gap-2">
                        <button onclick="copyInput()"
                            class="text-xs text-blue-600 hover:text-blue-800 transition flex items-center gap-1"
                            title="Copy to Clipboard">
                            <i class="ph ph-copy"></i> Copy
                        </button>
                        <button onclick="clearInput()"
                            class="text-xs text-stone-400 hover:text-red-500 transition">Clear</button>
                    </div>
                </div>
                <textarea id="move-input"
                    class="w-full h-24 p-3 border border-stone-200 rounded-lg font-mono text-xs focus:ring-2 focus:ring-stone-400 focus:outline-none resize-none text-stone-600 bg-stone-50"
                    placeholder="e.g. f5d6c3..."></textarea>

                <div class="flex flex-col gap-3 mt-3">
                    <button onclick="parseAndLoad()"
                        class="w-full bg-stone-800 hover:bg-stone-700 text-white font-bold py-2 px-4 rounded-lg transition text-sm flex items-center justify-center gap-2">
                        <i class="ph ph-upload-simple"></i> Load Game
                    </button>

                    <button id="btn-analyze" onclick="toggleAnalysisMode()"
                        class="w-full bg-stone-200 hover:bg-stone-300 text-stone-700 font-bold py-2 px-4 rounded-lg transition text-sm flex items-center justify-center gap-2 shadow-sm">
                        <i id="icon-analyze" class="ph ph-brain"></i> <span id="text-analyze">Analysis: OFF</span>
                    </button>

                    <!-- NEW: Collapsible Developer Mode -->
                    <div class="border border-stone-200 rounded-lg overflow-hidden bg-stone-50">
                        <button onclick="toggleDevSettings()"
                            class="w-full bg-stone-100 p-3 text-xs font-bold text-stone-600 flex justify-between items-center hover:bg-stone-200 transition">
                            <span class="flex items-center gap-2"><i class="ph ph-code"></i> Developer Mode</span>
                            <i id="dev-chevron" class="ph ph-caret-down transition-transform"></i>
                        </button>

                        <!-- Settings Panel (Hidden by default) -->
                        <div id="dev-settings-panel"
                            class="hidden p-3 flex flex-col gap-3 animate-in fade-in slide-in-from-top-2">
                            <div>
                                <div class="flex justify-between items-center text-xs font-bold text-stone-500 mb-2">
                                    <span>Engine Weights & Rules</span>
                                    <button onclick="resetWeights()"
                                        class="text-[10px] text-blue-600 hover:underline">Reset Defaults</button>
                                </div>

                                <!-- Hard Constraints Toggle -->
                                <div class="flex items-center justify-between mb-3 px-1">
                                    <span class="text-[10px] text-stone-700 font-bold">Hard Rules (Pos/Div/Star)</span>
                                    <div
                                        class="relative inline-block w-8 h-4 align-middle select-none transition duration-200 ease-in">
                                        <!-- Changed default to unchecked (OFF) -->
                                        <input type="checkbox" name="toggle" id="toggle-hard"
                                            class="toggle-checkbox absolute block w-4 h-4 rounded-full bg-white border-2 border-stone-300 appearance-none cursor-pointer"
                                            checked onchange="updateWeightsUI()" />
                                        <label for="toggle-hard"
                                            class="toggle-label block overflow-hidden h-4 rounded-full bg-stone-300 cursor-pointer"></label>
                                    </div>
                                </div>

                                <!-- Sliders -->
                                <div class="space-y-3">
                                    <!-- Regional Parity (New V2.5) -->
                                    <div>
                                        <div class="flex justify-between text-[10px] text-stone-600 font-semibold mb-1">
                                            <span class="text-pink-600">Closed Parity (FloodFill)</span>
                                            <span id="val-parity" class="font-bold text-pink-600">12</span>
                                        </div>
                                        <input type="range" id="slider-parity" min="0" max="60" value="12"
                                            class="weight-slider accent-pink-600" oninput="updateWeightsUI()">
                                    </div>

                                    <!-- Divergence -->
                                    <div>
                                        <div class="flex justify-between text-[10px] text-stone-600 font-semibold mb-1">
                                            <span>Divergence (Frontier)</span>
                                            <span id="val-div">28</span>
                                        </div>
                                        <input type="range" id="slider-div" min="0" max="60" value="28"
                                            class="weight-slider" oninput="updateWeightsUI()">
                                    </div>

                                    <!-- Mobility -->
                                    <div>
                                        <div class="flex justify-between text-[10px] text-stone-600 font-semibold mb-1">
                                            <span>Mobility (Moves)</span>
                                            <span id="val-mob">24</span>
                                        </div>
                                        <input type="range" id="slider-mob" min="0" max="60" value="24"
                                            class="weight-slider" oninput="updateWeightsUI()">
                                    </div>

                                    <!-- Stable -->
                                    <div>
                                        <div class="flex justify-between text-[10px] text-stone-600 font-semibold mb-1">
                                            <span>Stability (Safe Discs)</span>
                                            <span id="val-stable" class="text-indigo-600 font-bold">32</span>
                                        </div>
                                        <input type="range" id="slider-stable" min="0" max="60" value="32"
                                            class="weight-slider" oninput="updateWeightsUI()">
                                    </div>

                                    <!-- Flip Count -->
                                    <div>
                                        <div class="flex justify-between text-[10px] text-stone-600 font-semibold mb-1">
                                            <span>Flip Count (Forced)</span>
                                            <span id="val-flip">22</span>
                                        </div>
                                        <input type="range" id="slider-flip" min="0" max="60" value="22"
                                            class="weight-slider" oninput="updateWeightsUI()">
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Play with AI Button -->
                    <button id="btn-ai-play" onclick="handleAiButton()"
                        class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg transition text-sm flex items-center justify-center gap-2 shadow-md">
                        <i class="ph ph-robot"></i> Play with AI
                    </button>

                    <!-- Raw Values List -->
                    <div id="analysis-details-panel" class="hidden animate-in fade-in slide-in-from-top-1">
                        <div
                            class="text-[10px] font-bold text-stone-400 uppercase tracking-wide mb-1 flex justify-between">
                            <span>Evaluation Details</span>
                            <span class="text-stone-300">Raw Values</span>
                        </div>
                        <div id="analysis-results-text"
                            class="custom-scroll w-full p-2 bg-stone-50 border border-stone-200 rounded font-mono text-[10px] text-stone-600 h-28 overflow-y-auto leading-relaxed whitespace-pre-wrap">
                            Waiting for analysis...
                        </div>
                    </div>
                </div>
            </div>

            <div
                class="bg-white rounded-xl shadow-sm border border-stone-200 flex-1 flex flex-col overflow-hidden h-[400px] lg:h-[500px]">
                <div class="p-4 border-b border-stone-100 bg-stone-50">
                    <h2 class="text-sm font-bold text-stone-800 uppercase tracking-wide">Transcript</h2>
                </div>
                <div id="move-history-list" class="flex-1 overflow-y-auto p-0 relative">
                    <!-- List -->
                </div>
            </div>
        </div>
    </div>

    <!-- Credits Footer -->
    <div id="credits-footer"
        class="fixed bottom-2 right-2 md:bottom-2 md:right-4 text-[10px] text-stone-400 cursor-pointer hover:text-stone-600 transition-colors select-none font-medium opacity-80 z-50 bg-stone-100/50 px-2 py-1 rounded backdrop-blur-sm"
        onclick="editCredits()">
        Rain Optimized V2.5 | IID & ClosedParity
    </div>

    <!-- Turn Selection Modal -->
    <div id="turn-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3 class="text-lg font-bold text-stone-800 mb-2">Whose Turn?</h3>
            <p class="text-sm text-stone-500 mb-6">Both players have valid moves.</p>
            <div class="flex gap-4 justify-center">
                <button onclick="selectTurn(BLACK)"
                    class="flex-1 py-3 bg-stone-800 text-white rounded-lg hover:bg-stone-700 transition font-bold flex flex-col items-center gap-1">
                    <div class="w-4 h-4 rounded-full bg-black border border-stone-600"></div> Black
                </button>
                <button onclick="selectTurn(WHITE)"
                    class="flex-1 py-3 bg-white border border-stone-200 text-stone-800 rounded-lg hover:bg-stone-50 transition font-bold flex flex-col items-center gap-1">
                    <div class="w-4 h-4 rounded-full bg-white border border-stone-400"></div> White
                </button>
            </div>
        </div>
    </div>

    <!-- AI Selection Modal -->
    <div id="ai-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3 class="text-lg font-bold text-stone-800 mb-2">Play with AI</h3>
            <p class="text-sm text-stone-500 mb-6">Choose your side. (Rain V2.5)</p>
            <div class="flex flex-col gap-3">
                <button onclick="startAiGame(WHITE)"
                    class="w-full py-3 bg-stone-800 text-white rounded-lg hover:bg-stone-700 transition font-bold flex items-center justify-center gap-2">
                    <div class="w-3 h-3 rounded-full bg-white"></div> You as Black
                </button>
                <button onclick="startAiGame(BLACK)"
                    class="w-full py-3 bg-white border border-stone-200 text-stone-800 rounded-lg hover:bg-stone-50 transition font-bold flex items-center justify-center gap-2">
                    <div class="w-3 h-3 rounded-full bg-black"></div> You as White
                </button>
                <button onclick="startAiGame('BOTH')"
                    class="w-full py-3 bg-indigo-100 text-indigo-700 border border-indigo-200 rounded-lg hover:bg-indigo-200 transition font-bold flex items-center justify-center gap-2">
                    <i class="ph ph-robot"></i> AI Selfplay
                </button>
            </div>
            <button onclick="document.getElementById('ai-modal').classList.add('hidden')"
                class="mt-4 text-xs text-stone-400 hover:text-stone-600">Cancel</button>
        </div>
    </div>

    <script>
        const EMPTY = 0;
        const BLACK = 1;
        const WHITE = 2;
        const SIZE = 8;

        let gameHistory = [];
        let currentStepIndex = 0;

        // Analysis Vars
        let isAnalysisMode = false;

        // AI Vars
        let aiSide = null;
        let isAiThinking = false;

        // Edit Mode Vars
        let isEditMode = false;
        let editBrush = BLACK;
        let isDragging = false;

        // Weight Vars (V2.5: Parity Default 20)
        let engineWeights = {
            div: 28,
            mob: 24,
            stable: 32,
            flip: 22,
            parity: 12
        };
        // DEFAULT TO TRUE
        let useHardConstraints = true;

        const DEFAULT_GAME = "";


        // --- Analysis Manager (V2.5 RAIN UPDATE) ---
        const AnalysisManager = {
            workers: [],
            maxWorkers: navigator.hardwareConcurrency || 4,
            results: [],
            queue: [],
            isBusy: false,
            currentPhase: 'IDLE',
            targetStepIndex: -1,
            currentAnalysisId: 0,

            allMoves: [],
            preScanResults: [],
            top4Results: [],

            board: null,
            player: null,
            fullDepth: 9,
            halfDepth: 4,
            mode: 'hybrid',

            init: function () {
                this.terminate();
                for (let i = 0; i < this.maxWorkers; i++) {
                    const w = new Worker('./solver_worker.js');
                    w.onmessage = (e) => this.handleWorkerMessage(e.data);
                    this.workers.push(w);
                }
            },

            terminate: function () {
                this.workers.forEach(w => w.terminate());
                this.workers = [];
                this.isBusy = false;
                this.currentPhase = 'IDLE';
                updateStatusUI('IDLE');
            },

            startAnalysis: function (board2D, player, validMoves, onComplete = null) {
                if (this.workers.length === 0) this.init();

                this.targetStepIndex = currentStepIndex;
                this.currentAnalysisId++;
                const reqId = this.currentAnalysisId;

                this.isBusy = true;
                this.player = player;
                this.allMoves = validMoves;
                this.onAnalysisComplete = onComplete;
                this.results = [];
                this.preScanResults = [];
                this.top4Results = [];
                this.queue = [];

                const flatBoard = new Int8Array(64);
                for (let r = 0; r < 8; r++) for (let c = 0; c < 8; c++) flatBoard[r * 8 + c] = board2D[r][c];
                this.board = flatBoard;

                const emptyCount = countEmptySquares(board2D);
                const currentWeights = { ...engineWeights };
                const hardMode = document.getElementById('toggle-hard').checked;
                useHardConstraints = hardMode;

                const intMoves = validMoves.map(m => (m.x << 3) | m.y);

                this.mode = 'unified';
                this.currentPhase = 'UNIFIED';
                this.currentDepth = 64;
                updateEngineText(`Unified: Iterative Deepening`, 'text-indigo-600');
                updateStatusUI('WORKING', `Calculating (Iterative Deepening)...`);

                intMoves.forEach(m => {
                    this.queue.push({
                        board: flatBoard, player, move: m, reqId,
                        mode: 'hybrid', depth: this.currentDepth, alpha: -Infinity,
                        weights: currentWeights, hardConstraints: hardMode
                    });
                });
                this.dispatch();

                updateStopButton(true);
            },

            dispatch: function () {
                while (this.queue.length > 0) {
                    const task = this.queue.shift();
                    const workerIndex = this.queue.length % this.workers.length;
                    this.workers[workerIndex].postMessage(task);
                }
            },

            handleWorkerMessage: function (data) {
                if (this.targetStepIndex !== currentStepIndex) return;
                if (data.reqId !== this.currentAnalysisId) return;

                if (data.type === 'result_depth') {
                    if (this.currentPhase === 'UNIFIED') {
                        const idx = (data.x << 3) | data.y;
                        const existingIndex = this.results.findIndex(r => ((r.x << 3) | r.y) === idx);
                        const entry = { x: data.x, y: data.y, val: data.val, depth: data.depth, reqId: data.reqId, is_endgame: data.is_endgame === 1 };
                        if (existingIndex >= 0) this.results[existingIndex] = entry; else this.results.push(entry);
                        updateAnalysisUI(this.results, this.mode);
                        updateAnalysisText(this.results, this.mode);
                    }
                } else if (data.type === 'result') {
                    if (this.currentPhase === 'UNIFIED') {
                        const idx = (data.x << 3) | data.y;
                        const existingIndex = this.results.findIndex(r => ((r.x << 3) | r.y) === idx);
                        const prev = existingIndex >= 0 ? this.results[existingIndex] : null;
                        const entry = {
                            x: data.x, y: data.y, val: data.val, reqId: data.reqId,
                            depth: prev && prev.depth !== undefined ? prev.depth : undefined,
                            is_endgame: data.is_endgame === 1
                        };
                        if (existingIndex >= 0) this.results[existingIndex] = entry; else this.results.push(entry);
                        if (this.results.length === this.allMoves.length) {
                            updateAnalysisUI(this.results, this.mode);
                            updateAnalysisText(this.results, this.mode);
                            this.finishAnalysis();
                        }
                    }
                }
            },

            finishAnalysis: function () {
                if (this.targetStepIndex !== currentStepIndex) return;
                this.isBusy = false;
                this.currentPhase = 'IDLE';
                updateStatusUI('DONE', 'Finished Calculation');
                updateStopButton(false);
                if (this.onAnalysisComplete) this.onAnalysisComplete(this.results);
            }
        };

        // --- UI Helper Functions ---
        function updateStatusUI(state, text) {
            const pill = document.getElementById('status-bar-pill');
            const icon = document.getElementById('status-icon');
            const msg = document.getElementById('status-msg');
            pill.className = 'status-pill px-5 py-2 rounded-full text-xs font-bold flex items-center gap-2 shadow-sm border border-stone-200';
            if (state === 'IDLE') {
                pill.classList.add('status-idle');
                icon.className = 'ph ph-check-circle text-lg';
                msg.textContent = text || 'Ready';
            } else if (state === 'WORKING') {
                pill.classList.add('status-working');
                icon.className = 'ph ph-spinner animate-spin text-lg';
                msg.textContent = text || 'Calculating...';
            } else if (state === 'DONE') {
                pill.classList.add('status-done');
                icon.className = 'ph ph-check-circle text-lg';
                msg.textContent = 'Finished Calculation';
            }
        }

        function updateStopButton(isCalculating) {
            const analyzeBtn = document.getElementById('btn-analyze');
            const aiBtn = document.getElementById('btn-ai-play');

            if (isAnalysisMode) {
                if (isCalculating) {
                    analyzeBtn.classList.replace('bg-stone-200', 'bg-red-500');
                    analyzeBtn.classList.replace('hover:bg-stone-300', 'hover:bg-red-600');
                    analyzeBtn.classList.replace('text-stone-700', 'text-white');
                    analyzeBtn.innerHTML = '<i class="ph ph-stop-circle text-lg"></i> Stop Calculating';
                    analyzeBtn.onclick = stopAnalysis;
                } else {
                    analyzeBtn.classList.replace('bg-red-500', 'bg-stone-200');
                    analyzeBtn.classList.replace('hover:bg-red-600', 'hover:bg-stone-300');
                    analyzeBtn.classList.replace('text-white', 'text-stone-700');
                    analyzeBtn.innerHTML = '<i class="ph ph-brain"></i> Analysis: ON';
                    analyzeBtn.onclick = toggleAnalysisMode;
                }
            } else {
                analyzeBtn.classList.replace('bg-red-500', 'bg-stone-200');
                analyzeBtn.classList.replace('hover:bg-red-600', 'hover:bg-stone-300');
                analyzeBtn.classList.replace('text-white', 'text-stone-700');
                analyzeBtn.innerHTML = '<i class="ph ph-brain"></i> Analysis: OFF';
            }

            if (aiSide) {
                if (isCalculating) {
                    aiBtn.classList.remove('bg-indigo-600', 'hover:bg-indigo-700');
                    aiBtn.classList.add('bg-red-600', 'hover:bg-red-700');
                    aiBtn.innerHTML = '<i class="ph ph-stop-circle"></i> Stop Calculating';
                } else {
                    aiBtn.classList.remove('bg-red-600', 'hover:bg-red-700');
                    aiBtn.classList.add('bg-indigo-600', 'hover:bg-indigo-700');
                    aiBtn.innerHTML = '<i class="ph ph-robot"></i> Play with AI';
                }
            }
        }

        function updateEngineText(text, colorClass) {
            const el = document.getElementById('engine-type');
            el.textContent = text;
            el.className = "text-[10px] uppercase font-bold mt-1 " + colorClass;
        }

        // --- DEV MODE TOGGLE ---
        function toggleDevSettings() {
            const panel = document.getElementById('dev-settings-panel');
            const chevron = document.getElementById('dev-chevron');

            if (panel.classList.contains('hidden')) {
                panel.classList.remove('hidden');
                chevron.classList.add('rotate-180');
            } else {
                panel.classList.add('hidden');
                chevron.classList.remove('rotate-180');
            }
        }

        // Weight Control Functions
        function updateWeightsUI() {
            const d = parseInt(document.getElementById('slider-div').value);
            const m = parseInt(document.getElementById('slider-mob').value);
            const s = parseInt(document.getElementById('slider-stable').value);
            const f = parseInt(document.getElementById('slider-flip').value);
            const p = parseInt(document.getElementById('slider-parity').value);
            const h = document.getElementById('toggle-hard').checked;

            engineWeights = { div: d, mob: m, stable: s, flip: f, parity: p };
            useHardConstraints = h;

            document.getElementById('val-div').textContent = d;
            document.getElementById('val-mob').textContent = m;
            document.getElementById('val-stable').textContent = s;
            document.getElementById('val-flip').textContent = f;
            document.getElementById('val-parity').textContent = p;

            if (isAnalysisMode && !isAiThinking) {
                const e = countEmptySquares(gameHistory[currentStepIndex].board);
                if (e > 16) triggerAnalysisManager();
            }
        }

        function resetWeights() {
            document.getElementById('slider-div').value = 28;
            document.getElementById('slider-mob').value = 24;
            document.getElementById('slider-stable').value = 32;
            document.getElementById('slider-flip').value = 22;
            document.getElementById('slider-parity').value = 12;
            document.getElementById('toggle-hard').checked = true;
            updateWeightsUI();
        }

        function editCredits() {
            const currentText = document.getElementById('credits-footer').innerText;
            const pass = prompt("请输入密码以修改署名:");
            if (pass === "090202chuan") {
                const newText = prompt("请输入新的署名:", currentText);
                if (newText) {
                    document.getElementById('credits-footer').innerText = newText;
                    localStorage.setItem('rain_custom_credits', newText);
                }
            } else if (pass !== null) {
                alert("密码错误，权限不足。");
            }
        }

        window.onload = () => {
            const savedCredits = localStorage.getItem('rain_custom_credits');
            if (savedCredits) document.getElementById('credits-footer').innerText = savedCredits;

            document.getElementById('move-input').value = DEFAULT_GAME;
            parseAndLoad();

            document.addEventListener('keydown', (e) => {
                if (document.activeElement.tagName === 'TEXTAREA') return;
                if (isEditMode) return;
                if (e.key === 'ArrowLeft') step(-1);
                else if (e.key === 'ArrowRight') step(1);
                else if (e.key === 'Home') jumpToStep(0);
                else if (e.key === 'End') jumpToEnd();
            });
            updateBrushUI();
            document.addEventListener('mouseup', () => isDragging = false);
            updateWeightsUI();
        };

        function handleAiButton() {
            if (AnalysisManager.isBusy && aiSide) stopAnalysis();
            else if (aiSide) stopAiGame();
            else showAiModal();
        }

        function stopAnalysis() {
            if (AnalysisManager.workers.length > 0) {
                AnalysisManager.workers.forEach(w => {
                    try { w.postMessage({ type: 'stop' }); } catch { }
                });
            }
            AnalysisManager.terminate();
            if (aiSide) {
                isAiThinking = false;
                updateStatusUI('IDLE', 'Calculation Stopped');
            } else {
                updateStatusUI('IDLE', 'Analysis Stopped');
            }
            updateStopButton(false);
        }

        function createInitialBoard() {
            let b = Array(SIZE).fill().map(() => Array(SIZE).fill(EMPTY));
            b[3][3] = WHITE; b[4][3] = BLACK; b[3][4] = BLACK; b[4][4] = WHITE;
            return b;
        }
        function copyBoard(b) { return b.map(r => [...r]); }
        function getOpponent(p) { return p === BLACK ? WHITE : BLACK; }
        function isValidBounds(x, y) { return x >= 0 && x < SIZE && y >= 0 && y < SIZE; }

        function getFlippableDiscs(board, x, y, player) {
            if (board[x][y] !== EMPTY) return [];
            let opponent = getOpponent(player);
            let directions = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];
            let flips = [];
            for (let [dx, dy] of directions) {
                let r = x + dx, c = y + dy, potential = [];
                while (isValidBounds(r, c) && board[r][c] === opponent) {
                    potential.push({ x: r, y: c });
                    r += dx; c += dy;
                }
                if (isValidBounds(r, c) && board[r][c] === player && potential.length > 0) {
                    flips.push(...potential);
                }
            }
            return flips;
        }

        function canMove(board, player) {
            for (let x = 0; x < SIZE; x++) for (let y = 0; y < SIZE; y++)
                if (getFlippableDiscs(board, x, y, player).length > 0) return true;
            return false;
        }
        function stringToCoord(s) {
            if (!s || s.length < 2) return null;
            const cols = { 'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7 };
            let x = cols[s[0].toLowerCase()];
            let y = parseInt(s[1]) - 1;
            if (x === undefined || isNaN(y)) return null;
            return { x, y };
        }
        function coordToString(x, y) { return "abcdefgh"[x] + (y + 1); }
        function countDiscs(board) {
            let b = 0, w = 0;
            board.forEach(row => row.forEach(c => { if (c === BLACK) b++; else if (c === WHITE) w++; }));
            return { b, w };
        }
        function countEmptySquares(b) {
            let count = 0;
            for (let r = 0; r < SIZE; r++) for (let c = 0; c < SIZE; c++) if (b[r][c] === EMPTY) count++;
            return count;
        }

        function parseAndLoad() {
            const inputStr = document.getElementById('move-input').value.trim();
            const moveStrings = inputStr.match(/.{1,2}/g) || [];
            gameHistory = [];
            let currentBoard = createInitialBoard();
            let currentPlayer = BLACK;
            gameHistory.push({ board: copyBoard(currentBoard), player: currentPlayer, lastMove: null, moveStr: "Start", moveIndex: 0, counts: countDiscs(currentBoard) });
            let moveIdx = 0;
            let parseIdx = 0;
            while (parseIdx < moveStrings.length) {
                if (!canMove(currentBoard, currentPlayer)) {
                    currentPlayer = getOpponent(currentPlayer);
                    gameHistory.push({ board: copyBoard(currentBoard), player: currentPlayer, lastMove: { x: -1, y: -1 }, moveStr: "Pass", moveIndex: ++moveIdx, counts: countDiscs(currentBoard) });
                    if (!canMove(currentBoard, currentPlayer)) break;
                    continue;
                }
                let mStr = moveStrings[parseIdx];
                let coord = stringToCoord(mStr);
                if (coord && isValidBounds(coord.x, coord.y)) {
                    let flips = getFlippableDiscs(currentBoard, coord.x, coord.y, currentPlayer);
                    if (flips.length > 0) {
                        currentBoard[coord.x][coord.y] = currentPlayer;
                        flips.forEach(p => currentBoard[p.x][p.y] = currentPlayer);
                        currentPlayer = getOpponent(currentPlayer);
                        parseIdx++;
                        gameHistory.push({ board: copyBoard(currentBoard), player: currentPlayer, lastMove: coord, moveStr: mStr.toLowerCase(), moveIndex: ++moveIdx, counts: countDiscs(currentBoard) });
                    } else { parseIdx++; }
                } else { parseIdx++; }
            }
            document.getElementById('history-slider').max = gameHistory.length - 1;
            renderHistoryList();
            jumpToEnd();
        }

        function toggleEditMode() {
            isEditMode = !isEditMode;
            if (aiSide) stopAiGame();
            const sidebar = document.getElementById('sidebar-panel');
            const nav = document.getElementById('nav-controls');
            const editBar = document.getElementById('editor-toolbar');
            const btn = document.getElementById('btn-edit-toggle');
            if (isEditMode) {
                stopAnalysis();
                sidebar.classList.add('edit-overlay');
                nav.classList.add('edit-overlay');
                editBar.classList.remove('hidden');
                btn.classList.add('hidden');
                uiRenderCurrentState();
            } else {
                finishEditing();
            }
        }
        function setBrush(type) { editBrush = type; updateBrushUI(); }
        function updateBrushUI() {
            document.getElementById('brush-black').classList.remove('brush-active');
            document.getElementById('brush-white').classList.remove('brush-active');
            document.getElementById('brush-empty').classList.remove('brush-active');
            if (editBrush === BLACK) document.getElementById('brush-black').classList.add('brush-active');
            else if (editBrush === WHITE) document.getElementById('brush-white').classList.add('brush-active');
            else document.getElementById('brush-empty').classList.add('brush-active');
        }
        function handleBoardMouseDown(e) {
            if (!isEditMode) return;
            isDragging = true;
            const cell = e.target.closest('.cell');
            if (cell) {
                const [_, x, y] = cell.id.split('-');
                applyEdit(parseInt(x), parseInt(y));
            }
            document.addEventListener('mousemove', handleBoardMouseMove);
        }
        function handleBoardMouseUp(e) {
            if (!isEditMode) return;
            isDragging = false;
            document.removeEventListener('mousemove', handleBoardMouseMove);
        }
        function handleBoardMouseMove(e) {
            if (!isEditMode || !isDragging) return;
            const el = document.elementFromPoint(e.clientX, e.clientY);
            if (el) {
                const cell = el.closest('.cell');
                if (cell) {
                    const [_, x, y] = cell.id.split('-');
                    applyEdit(parseInt(x), parseInt(y));
                }
            }
        }
        function handleBoardTouchStart(e) {
            if (!isEditMode) return;
            e.preventDefault();
            isDragging = true;
            const touch = e.touches[0];
            const el = document.elementFromPoint(touch.clientX, touch.clientY);
            if (el) {
                const cell = el.closest('.cell');
                if (cell) {
                    const [_, x, y] = cell.id.split('-');
                    applyEdit(parseInt(x), parseInt(y));
                }
            }
        }
        function handleBoardTouchEnd(e) { isDragging = false; }
        document.getElementById('board').addEventListener('touchmove', function (e) {
            if (!isEditMode || !isDragging) return;
            e.preventDefault();
            const touch = e.touches[0];
            const el = document.elementFromPoint(touch.clientX, touch.clientY);
            if (el) {
                const cell = el.closest('.cell');
                if (cell) {
                    const [_, x, y] = cell.id.split('-');
                    applyEdit(parseInt(x), parseInt(y));
                }
            }
        }, { passive: false });

        function applyEdit(x, y) {
            let state = gameHistory[currentStepIndex];
            if (state.board[x][y] !== editBrush) {
                state.board[x][y] = editBrush;
                state.counts = countDiscs(state.board);
                uiRenderCurrentState();
            }
        }
        function finishEditing() {
            const state = gameHistory[currentStepIndex];
            const board = state.board;
            const bCanMove = canMove(board, BLACK);
            const wCanMove = canMove(board, WHITE);
            if (bCanMove && wCanMove) document.getElementById('turn-modal').classList.remove('hidden');
            else if (bCanMove) finalizeEdit(BLACK);
            else if (wCanMove) finalizeEdit(WHITE);
            else finalizeEdit(BLACK);
        }
        function selectTurn(player) {
            document.getElementById('turn-modal').classList.add('hidden');
            finalizeEdit(player);
        }
        function finalizeEdit(nextPlayer) {
            isEditMode = false;
            document.getElementById('sidebar-panel').classList.remove('edit-overlay');
            document.getElementById('nav-controls').classList.remove('edit-overlay');
            document.getElementById('editor-toolbar').classList.add('hidden');
            document.getElementById('btn-edit-toggle').classList.remove('hidden');
            const state = gameHistory[currentStepIndex];
            const newBoard = copyBoard(state.board);
            gameHistory = [];
            gameHistory.push({ board: newBoard, player: nextPlayer, lastMove: null, moveStr: "Setup", moveIndex: 0, counts: countDiscs(newBoard) });
            currentStepIndex = 0;
            document.getElementById('move-input').value = "";
            document.getElementById('history-slider').max = 0;
            document.getElementById('history-slider').value = 0;
            renderHistoryList();
            uiRenderCurrentState();
            if (isAnalysisMode) triggerAnalysisManager();
        }

        function showAiModal() {
            if (isEditMode) return;
            document.getElementById('ai-modal').classList.remove('hidden');
        }
        function startAiGame(side) {
            aiSide = side;
            document.getElementById('ai-modal').classList.add('hidden');
            document.getElementById('game-result-msg').classList.add('hidden');
            document.getElementById('analysis-details-panel').classList.remove('hidden');
            updateStopButton(false);
            triggerAiTurn();
        }
        function stopAiGame() {
            aiSide = null;
            isAiThinking = false;
            stopAnalysis();
            uiRenderCurrentState();
        }

        function triggerAiTurn() {
            if (!aiSide) return;
            const state = gameHistory[currentStepIndex];
            const player = state.player;
            if (!canMove(state.board, BLACK) && !canMove(state.board, WHITE)) {
                showGameResult(state.counts);
                stopAiGame();
                return;
            }
            const isAiTurn = (aiSide === 'BOTH') || (aiSide === BLACK && player === BLACK) || (aiSide === WHITE && player === WHITE);
            if (isAiTurn) {
                clearEvaluationScores();
                let validMoves = [];
                for (let x = 0; x < SIZE; x++) for (let y = 0; y < SIZE; y++)
                    if (getFlippableDiscs(state.board, x, y, state.player).length > 0) validMoves.push({ x, y });

                if (validMoves.length === 0) {
                    makeMove(-1, -1);
                } else if (validMoves.length === 1) {
                    isAiThinking = true;
                    updateStatusUI('WORKING', 'Forced Move...');
                    setTimeout(() => makeMove(validMoves[0].x, validMoves[0].y), 500);
                } else {
                    isAiThinking = true;
                    AnalysisManager.startAnalysis(state.board, state.player, validMoves, (results) => {
                        let best = results[0];
                        for (let r of results) { if (r.val > best.val) best = r; }
                        makeMove(best.x, best.y);
                    });
                }
            } else {
                updateStatusUI('IDLE', 'Your Turn');
                let validMoves = [];
                for (let x = 0; x < SIZE; x++) for (let y = 0; y < SIZE; y++)
                    if (getFlippableDiscs(state.board, x, y, state.player).length > 0) validMoves.push({ x, y });
                if (validMoves.length === 0) setTimeout(() => makeMove(-1, -1), 800);
            }
        }

        function makeMove(x, y) {
            isAiThinking = false;
            const currentState = gameHistory[currentStepIndex];
            const board = currentState.board;
            const player = currentState.player;
            let newBoard = copyBoard(board);
            let nextPlayer = getOpponent(player);
            let moveStr = "";
            if (x === -1) {
                moveStr = "Pass";
            } else {
                const flips = getFlippableDiscs(board, x, y, player);
                if (flips.length === 0) return;
                newBoard[x][y] = player;
                flips.forEach(p => newBoard[p.x][p.y] = player);
                moveStr = coordToString(x, y);
            }
            gameHistory = gameHistory.slice(0, currentStepIndex + 1);
            gameHistory.push({ board: newBoard, player: nextPlayer, lastMove: { x, y }, moveStr: moveStr, moveIndex: currentState.moveIndex + 1, counts: countDiscs(newBoard) });
            updateInputFromHistory();
            currentStepIndex++;
            document.getElementById('history-slider').max = gameHistory.length - 1;
            document.getElementById('history-slider').value = currentStepIndex;
            renderHistoryList();
            stopAnalysis();
            uiRenderCurrentState();
            uiScrollHistory();
            if (aiSide) triggerAiTurn();
            else if (isAnalysisMode) triggerAnalysisManager();
        }

        function showGameResult(counts) {
            const el = document.getElementById('game-result-msg');
            const title = document.getElementById('result-title');
            const score = document.getElementById('result-score');
            el.classList.remove('hidden');
            score.textContent = `Black: ${counts.b} - White: ${counts.w}`;
            if (counts.b > counts.w) {
                title.textContent = "Black Wins!";
                title.className = "text-2xl font-bold text-center mb-1 text-white";
            } else if (counts.w > counts.b) {
                title.textContent = "White Wins!";
                title.className = "text-2xl font-bold text-center mb-1 text-white";
            } else {
                title.textContent = "Draw!";
                title.className = "text-2xl font-bold text-center mb-1 text-gray-300";
            }
            setTimeout(() => el.classList.add('hidden'), 5000);
        }

        function handleBoardClick(x, y) {
            if (isEditMode) return;
            const state = gameHistory[currentStepIndex];
            if (aiSide === 'BOTH') return;
            if ((aiSide === BLACK && state.player === BLACK) || (aiSide === WHITE && state.player === WHITE)) return;
            isAiThinking = false;
            makeMove(x, y);
        }
        function updateInputFromHistory() {
            let str = "";
            for (let i = 1; i < gameHistory.length; i++) {
                let h = gameHistory[i];
                if (h.lastMove && h.lastMove.x !== -1) str += h.moveStr;
            }
            document.getElementById('move-input').value = str;
        }
        function jumpToStep(idx) {
            if (idx < 0) idx = 0;
            if (idx >= gameHistory.length) idx = gameHistory.length - 1;
            if (aiSide) stopAiGame();
            currentStepIndex = idx;
            document.getElementById('history-slider').value = idx;
            stopAnalysis();
            uiRenderCurrentState();
            uiScrollHistory();
            if (isAnalysisMode && !aiSide) triggerAnalysisManager();
        }
        function jumpToEnd() { jumpToStep(gameHistory.length - 1); }
        function step(delta) { jumpToStep(currentStepIndex + delta); }
        function clearInput() {
            if (isEditMode) return;
            if (aiSide) stopAiGame();
            document.getElementById('move-input').value = "";
            document.getElementById('move-input').focus();
        }
        function copyInput() {
            if (isEditMode) return;
            const copyText = document.getElementById("move-input");
            copyText.select();
            document.execCommand("copy");
            const btn = document.querySelector('button[title="Copy to Clipboard"]');
            const originalHTML = btn.innerHTML;
            btn.innerHTML = '<i class="ph ph-check"></i> Copied';
            setTimeout(() => { btn.innerHTML = originalHTML; }, 1000);
        }

        function renderHistoryList() {
            const list = document.getElementById('move-history-list');
            list.innerHTML = '';
            let startDiv = document.createElement('div');
            startDiv.className = `px-4 py-2 border-b border-stone-100 cursor-pointer hover:bg-stone-100 text-xs font-mono flex justify-between ${currentStepIndex === 0 ? 'active-move' : ''}`;
            startDiv.innerHTML = `<span>0. Start</span><span>-</span>`;
            startDiv.onclick = () => jumpToStep(0);
            startDiv.id = `hist-item-0`;
            list.appendChild(startDiv);
            for (let i = 1; i < gameHistory.length; i++) {
                let state = gameHistory[i];
                let isBlackMove = (gameHistory[i - 1].player === BLACK);
                let moveNum = state.moveIndex;
                let div = document.createElement('div');
                div.id = `hist-item-${i}`;
                div.className = `px-4 py-2 border-b border-stone-100 cursor-pointer hover:bg-stone-100 text-xs font-mono flex justify-between transition-colors ${i === currentStepIndex ? 'active-move' : ''}`;
                div.onclick = () => jumpToStep(i);
                div.innerHTML = `
                    <span class="text-stone-500 w-6 text-right mr-2">${moveNum}.</span>
                    <span class="${isBlackMove ? 'text-black font-bold' : 'text-stone-600 font-bold'}">${isBlackMove ? '●' : '○'} ${state.moveStr}</span>
                    <span class="text-stone-400 text-[10px]">${state.counts.b}-${state.counts.w}</span>
                `;
                list.appendChild(div);
            }
        }
        function uiScrollHistory() {
            document.querySelectorAll('#move-history-list > div').forEach(el => el.classList.remove('active-move'));
            let activeItem = document.getElementById(`hist-item-${currentStepIndex}`);
            if (activeItem) {
                activeItem.classList.add('active-move');
                const container = document.getElementById('move-history-list');
                const itemTop = activeItem.offsetTop;
                const itemHeight = activeItem.offsetHeight;
                const containerHeight = container.offsetHeight;
                container.scrollTop = itemTop - (containerHeight / 2) + (itemHeight / 2);
            }
        }

        function uiRenderCurrentState() {
            const state = gameHistory[currentStepIndex];
            if (!state) return;

            clearEvaluationScores();

            const board = state.board;
            const lastMove = state.lastMove;
            const counts = state.counts;
            const nextPlayer = state.player;
            const showNumbers = document.getElementById('show-numbers').checked;
            const showLegal = document.getElementById('show-legal').checked;

            const boardEl = document.getElementById('board');
            boardEl.innerHTML = '';

            let legalMoves = [];
            if (!isEditMode) {
                for (let x = 0; x < SIZE; x++)
                    for (let y = 0; y < SIZE; y++)
                        if (getFlippableDiscs(board, x, y, nextPlayer).length > 0) legalMoves.push(`${x},${y}`);
            }

            if (!isEditMode && !isAiThinking && currentStepIndex === gameHistory.length - 1) {
                const canCurrent = legalMoves.length > 0;
                const canOpponent = canMove(board, getOpponent(nextPlayer));
                const isGameOver = !canCurrent && !canOpponent;
                if (!canCurrent && !isGameOver && !aiSide) {
                    updateStatusUI('WORKING', `No moves for ${nextPlayer === BLACK ? 'Black' : 'White'}. Auto Passing...`);
                    setTimeout(() => { if (currentStepIndex === gameHistory.length - 1) { makeMove(-1, -1); } }, 800);
                }
            }

            for (let y = 0; y < SIZE; y++) {
                for (let x = 0; x < SIZE; x++) {
                    let cell = document.createElement('div');
                    cell.className = 'cell relative flex justify-center items-center cursor-pointer';
                    cell.id = `cell-${x}-${y}`;
                    if (!isEditMode) cell.onclick = () => handleBoardClick(x, y);
                    if (board[x][y] !== EMPTY) {
                        let disc = document.createElement('div');
                        disc.className = `disc ${board[x][y] === BLACK ? 'black' : 'white'}`;
                        if (showNumbers && lastMove && lastMove.x === x && lastMove.y === y && !isEditMode) {
                            disc.innerText = state.moveIndex;
                            disc.style.color = board[x][y] === BLACK ? 'white' : 'black';
                        }
                        cell.appendChild(disc);
                    }
                    if (lastMove && lastMove.x === x && lastMove.y === y && !showNumbers && !isEditMode) {
                        let marker = document.createElement('div');
                        marker.className = 'last-move-marker';
                        cell.appendChild(marker);
                    }
                    if (showLegal && legalMoves.includes(`${x},${y}`) && !isEditMode && !aiSide) {
                        let hint = document.createElement('div');
                        hint.className = 'legal-move-hint';
                        cell.appendChild(hint);
                    }
                    boardEl.appendChild(cell);
                }
            }
            document.getElementById('black-count').textContent = counts.b;
            document.getElementById('white-count').textContent = counts.w;

            const blackDot = document.getElementById('black-turn-dot');
            const whiteDot = document.getElementById('white-turn-dot');
            const blackInd = document.getElementById('black-indicator');
            const whiteInd = document.getElementById('white-indicator');

            if (isEditMode) {
                updateStatusUI('IDLE', 'Editing...');
                blackDot.style.opacity = '0'; whiteDot.style.opacity = '0';
                blackInd.style.borderColor = 'transparent'; whiteInd.style.borderColor = 'transparent';
                document.getElementById('move-text').textContent = "Place discs freely";
                return;
            }

            if (nextPlayer === BLACK) {
                blackDot.style.opacity = '1'; whiteDot.style.opacity = '0';
                blackInd.style.borderColor = '#444'; whiteInd.style.borderColor = 'transparent';
                document.getElementById('status-text').textContent = "Black's Turn";
            } else {
                blackDot.style.opacity = '0'; whiteDot.style.opacity = '1';
                blackInd.style.borderColor = 'transparent'; whiteInd.style.borderColor = '#d6d3d1';
                document.getElementById('status-text').textContent = "White's Turn";
            }

            if (!canMove(board, BLACK) && !canMove(board, WHITE)) {
                updateStatusUI('DONE', 'Game Over');
                if (counts.b > counts.w) document.getElementById('status-text').textContent += " (Black)";
                else if (counts.w > counts.b) document.getElementById('status-text').textContent += " (White)";
                else document.getElementById('status-text').textContent += " (Draw)";
            } else if (!isAiThinking && !AnalysisManager.isBusy) {
                if (legalMoves.length > 0) updateStatusUI('IDLE', 'Ready');
            }

            if (lastMove) {
                let pName = (state.player === BLACK) ? "White" : "Black";
                let mText = lastMove.x === -1 ? "Passed" : coordToString(lastMove.x, lastMove.y);
                document.getElementById('move-text').textContent = `Last: ${pName} to ${mText}`;
            } else {
                document.getElementById('move-text').textContent = "Start";
            }
        }

        function toggleAnalysisMode() {
            if (isEditMode) return;
            if (aiSide) return;

            if (isAnalysisMode && AnalysisManager.isBusy) {
                stopAnalysis();
                isAnalysisMode = false;
                return;
            }

            isAnalysisMode = !isAnalysisMode;

            if (isAnalysisMode) {
                document.getElementById('analysis-details-panel').classList.remove('hidden');
                triggerAnalysisManager();
            } else {
                document.getElementById('analysis-details-panel').classList.add('hidden');
                stopAnalysis();
                updateEngineText("Engine: Standby", "text-stone-400");
            }
        }

        function clearEvaluationScores() { document.querySelectorAll('.eval-score').forEach(el => el.remove()); }

        function triggerAnalysisManager() {
            if (isEditMode) return;
            const state = gameHistory[currentStepIndex];
            if (!state) return;
            let moves = [];
            for (let x = 0; x < SIZE; x++)
                for (let y = 0; y < SIZE; y++)
                    if (getFlippableDiscs(state.board, x, y, state.player).length > 0) moves.push({ x, y });
            if (moves.length === 0) return;
            AnalysisManager.startAnalysis(state.board, state.player, moves);
        }

        function updateAnalysisUI(results, mode) {
            if (isAiThinking && aiSide) return;
            if (results.length === 0) return;
            clearEvaluationScores();
            let sorted = [...results].sort((a, b) => b.val - a.val);
            const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
            sorted.forEach((r, rankIndex) => {
                let text = "";
                let styleClass = "score-normal";
                let shouldRender = false;
                if (mode === 'perfect_solver' || mode === 'endgame_sniper' || mode === 'endgame') {
                    const diff = Math.round(r.val / 1000);
                    text = diff > 0 ? `胜${diff}` : (diff < 0 ? `负${-diff}` : `平局`);
                    styleClass = (rankIndex === 0) ? "score-best" : "score-normal";
                    shouldRender = true;
                } else if (mode === 'unified') {
                    if (r.is_endgame) {
                        const diff = Math.round(r.val / 1000);
                        text = diff > 0 ? `胜${diff}` : (diff < 0 ? `负${-diff}` : `平局`);
                    } else {
                        let v = r.val.toFixed(2);
                        text = (r.val > 0 ? "+" + v : v);
                    }
                    styleClass = (rankIndex === 0) ? "score-best" : "score-normal";
                    shouldRender = true;
                } else {
                    text = alphabet[rankIndex];
                    styleClass = (rankIndex === 0) ? "score-best" : "score-normal";
                    shouldRender = true;
                }
                if (shouldRender) renderSingleScore(r.x, r.y, text, styleClass);
            });
        }

        function updateAnalysisText(results, mode) {
            const container = document.getElementById('analysis-results-text');
            let sorted = [...results].sort((a, b) => b.val - a.val);
            let html = sorted.map((r, i) => {
                let coord = coordToString(r.x, r.y);
                let valStr = "";
                if (mode.includes('perfect_solver') || mode.includes('endgame')) {
                    const diff = Math.round(r.val / 1000);
                    valStr = diff > 0 ? `胜${diff}` : (diff < 0 ? `负${-diff}` : `平局`);
                } else if (mode === 'unified') {
                    if (r.is_endgame) {
                        const diff = Math.round(r.val / 1000);
                        valStr = diff > 0 ? `胜${diff}` : (diff < 0 ? `负${-diff}` : `平局`);
                    } else {
                        let v = r.val.toFixed(2);
                        valStr = (r.val > 0 ? "+" + v : v) + (r.depth !== undefined ? ` (Depth ${r.depth})` : "");
                    }
                } else {
                    let v = r.val.toFixed(2);
                    valStr = (r.val > 0 ? "+" + v : v);
                }
                let isTop4 = (i < 4);
                if (mode === 'endgame_sniper' && !isTop4) return '';
                let prefix = (isTop4 && !mode.includes('perfect_solver') && !mode.includes('endgame') && mode !== 'unified') ? `<span class="font-bold text-stone-800">[${"ABCD"[i]}]</span> ` : `<span class="text-stone-400">#${i + 1}</span> `;
                return `${prefix}${coord}: ${valStr}`;
            }).filter(s => s !== '').join('\n');
            container.innerHTML = html;
        }

        function renderSingleScore(x, y, text, styleClass) {
            const cell = document.getElementById(`cell-${x}-${y}`);
            if (!cell) return;
            if (cell.querySelector('.disc')) return;
            const currentState = gameHistory[currentStepIndex];
            if (currentState && currentState.board[x][y] !== EMPTY) return;
            const existing = cell.querySelector('.eval-score');
            if (existing) existing.remove();
            let span = document.createElement('span');
            span.className = `eval-score ${styleClass}`;
            span.textContent = text;
            cell.appendChild(span);
        }
    </script>
    <script type="module" src="/index.tsx"></script>
</body>

</html>
